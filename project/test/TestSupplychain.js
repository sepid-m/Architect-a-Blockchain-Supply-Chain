// This script is designed to test the solidity smart contract - SuppyChain.sol -- and the various functions within
// Declare a variable and assign the compiled smart contract artifact
const SupplyChain = artifacts.require('SupplyChain');
const Web3 = require('web3');
const web3 = new Web3(new Web3.providers.HttpProvider("http://localhost:7545"));



contract('SupplyChain', accounts => {
    // Declare few constants and assign a few sample accounts generated by ganache-cli
    var sku = 1;
    var upc = 1;
    const ownerID = accounts[0];
    const newOwnerID = accounts[1];
    const fakeOwnerID = accounts[2];
    const originPoultererID = accounts[3];
    const originFarmName = "Mihan Dairy";
    const originFarmInformation = "A dairy factory which try to produce fresh and organic milk!";
    const originFarmLatitude = "-38.239770";
    const originFarmLongitude = "144.341490";
    const productNotes = "Fresh and organic milk!";
    const productPrice1 = web3.utils.toWei('1', "ether");
    const productPrice2 = web3.utils.toWei('1.5', "ether");
    const productPrice3 = web3.utils.toWei('2', "ether");
    const productPrice4 = web3.utils.toWei('2.5', "ether");
    const productPrice5 = web3.utils.toWei('3', "ether");
    let productID = sku + upc;
    const dairyfactoryID = accounts[4];
    const distributorID = accounts[5];
    const retailerID = accounts[6];
    const supermarketID = accounts[7]; 
    const consumerID = accounts[8]
    const emptyAddress = 0;
    let tx;

    ///Available Accounts
    ///==================
    ///(0) 0x27d8d15cbc94527cadf5ec14b69519ae23288b95
    ///(1) 0x018c2dabef4904ecbd7118350a0c54dbeae3549a
    ///(2) 0xce5144391b4ab80668965f2cc4f2cc102380ef0a
    ///(3) 0x460c31107dd048e34971e57da2f99f659add4f02
    ///(4) 0xd37b7b8c62be2fdde8daa9816483aebdbd356088
    ///(5) 0x27f184bdc0e7a931b507ddd689d76dba10514bcb
    ///(6) 0xfe0df793060c49edca5ac9c104dd8e3375349978
    ///(7) 0xbd58a85c96cc6727859d853086fe8560bc137632
    ///(8) 0xe07b5ee5f738b2f87f88b99aac9c64ff1e0c7917
    ///(9) 0xbd3ff2e3aded055244d66544c9c059fa0851da44

    console.log("ganache-cli accounts used here...");
    console.log("Contract Owner: accounts[0] ", accounts[0]);
    console.log("Farmer: accounts[3] ", accounts[3]);
    console.log("Dairtyfactory: accounts[4] ", accounts[4]);
    console.log("Distributor: accounts[5] ", accounts[5]);
    console.log("Retailer: accounts[6] ", accounts[6]);
    console.log("Supermarket: accounts[7] ", accounts[7]);
    console.log("Consumer: accounts[8] ", accounts[8])

    describe('Check ownable functions', () => {
        beforeEach(async () => { 
            this.contract = await SupplyChain.new({from: accounts[0]});
        });

        it('Contract Owner is correct', async () => {
            assert.equal(await this.contract.isOwner({from: ownerID}), true);
        });

        it('Contract Owner is not correct', async () => {
            assert.equal(await this.contract.isOwner({from: fakeOwnerID}), false);
        });

        it('Only contract owner can transfer ownership', async () => {
            // fakeOwnerID try to transfer the ownership to newOwnerID but it is no possible
            await expectThrow(this.contract.transferOwnership(newOwnerID, {from: fakeOwnerID})); 
        });

        it('Contract owner transfers ownership new owner account', async () => {
            // ownerID transfer the ownership to newOwnerID
            tx = await this.contract.transferOwnership(newOwnerID, {from: ownerID});

            assert.equal(tx.logs[0].event, 'TransferOwnership');
            assert.equal(tx.logs[0].args.oldOwner, ownerID);
            assert.equal(tx.logs[0].args.newOwner, newOwnerID);
            assert.equal(await this.contract.isOwner({from: newOwnerID}), true);
        });

        it('Renunce contract ownership', async () => {
            tx = await this.contract.renounceOwnership({from: ownerID});
            assert.equal(tx.logs[0].event, 'TransferOwnership');
            assert.equal(tx.logs[0].args.oldOwner, ownerID);
            assert.equal(tx.logs[0].args.newOwner, emptyAddress);
        });
    });

    describe('Testing SupplyChain smart contract functions to check the journey of a item through the supply chain flow.', () => {

        before(async () => { 
            this.contract = await SupplyChain.new({from: accounts[0]});
        });

        it('Check a poulterer has been added to the smart contract', async () => {
            // Add poulterer to the struct
            tx = await this.contract.addPoulterer(originPoultererID, {from: ownerID});

            assert.equal(tx.logs[0].event, 'PoultererAdded');
            assert.equal(tx.logs[0].args.account, originPoultererID);
        });

        it('Check a dairyfactory has been added to the smart contract', async () => {
            // Add dairyfactory to the struct
            tx = await this.contract.addDairyfactory(dairyfactoryID, {from: ownerID});

            assert.equal(tx.logs[0].event, 'DairyfactoryAdded');
            assert.equal(tx.logs[0].args.account, dairyfactoryID);
        });

        it('Check a distributor has been added to the smart contract', async () => {
            // Add distributor to the struct
            tx = await this.contract.addDistributor(distributorID, {from: ownerID});

            assert.equal(tx.logs[0].event, 'DistributorAdded');
            assert.equal(tx.logs[0].args.account, distributorID);
        });

        it('Check a retailer has been added to the smart contract', async () => {
            // Add retailer to the struct
            tx = await this.contract.addRetailer(retailerID, {from: ownerID});

            assert.equal(tx.logs[0].event, 'RetailerAdded');
            assert.equal(tx.logs[0].args.account, retailerID);
        });

        it('Check a supermarket has been added to the smart contract', async () => {
            // Add supermarket to the struct
            tx = await this.contract.addSupermarket(supermarketID, {from: ownerID});

            assert.equal(tx.logs[0].event, 'SupermarketAdded');
            assert.equal(tx.logs[0].args.account, supermarketID);
        });

        it('Check a consumer has been added to the smart contract', async () => {
            // Add consumer to the struct
            tx = await this.contract.addConsumer(consumerID, {from: ownerID});

            assert.equal(tx.logs[0].event, 'ConsumerAdded');
            assert.equal(tx.logs[0].args.account, consumerID);
        });

        it('Call function obtainMilk() that allows a poulterer to obtain milk', async () => {
            tx = await this.contract.obtainItem(
                upc,
                originPoultererID,
                originFarmName,
                originFarmInformation,
                originFarmLatitude,
                originFarmLongitude,
                productNotes,
                {from: originPoultererID}
            );

            assert.equal(tx.logs[0].event, 'Obtained');
            assert.equal(tx.logs[0].args.upc, upc);
            assert.equal(tx.logs[0].args.emiter, originPoultererID);

            // Fetch the data for the added dan previously
            const resultBufferOne = await this.contract.fetchItemBufferPublic.call(upc);

            // Verify the result set
            assert.equal(resultBufferOne[0], sku, 'Error: Invalid item SKU');
            assert.equal(resultBufferOne[1], upc, 'Error: Invalid item UPC');
            assert.equal(resultBufferOne[2], originPoultererID, 'Error: Missing or Invalid ownerID');
            assert.equal(resultBufferOne[3], originPoultererID, 'Error: Missing or Invalid originPoultererID');
            assert.equal(resultBufferOne[4], originFarmName, 'Error: Missing or Invalid originFarmName');
            assert.equal(resultBufferOne[5], originFarmInformation, 'Error: Missing or Invalid originFarmInformation');
            assert.equal(resultBufferOne[6], originFarmLatitude, 'Error: Missing or Invalid originFarmLatitude');
            assert.equal(resultBufferOne[7], originFarmLongitude, 'Error: Missing or Invalid originFarmLongitude');
            assert.equal(resultBufferOne[8], 0, 'Error: Invalid item State');
        });

        it('Call function storeItem() that allows a poulterer to store metal', async () => {
            tx = await this.contract.storeItem(upc, {from: originPoultererID});

            assert.equal(tx.logs[0].event, 'Stored');
            assert.equal(tx.logs[0].args.upc, upc);
            assert.equal(tx.logs[0].args.emiter, originPoultererID);

            // Fetch the data for the added dan previously
            const resultBufferOne = await this.contract.fetchItemBufferPublic.call(upc);

            // Verify the result set. Item state will be Stored 
            assert.equal(resultBufferOne[8], 1, 'Error: Invalid item State');
        });

        it('Call function sellToDairyfactory() that allows a poulterer to sell milk to dairy factory', async () => {
            // Call function sellToDairyfactory()
            tx = await this.contract.sellToDairyfactory(upc, productPrice1, {from: originPoultererID});

            assert.equal(tx.logs[0].event, 'ForSaleToDairyfactory');
            assert.equal(tx.logs[0].args.upc, upc);
            assert.equal(tx.logs[0].args.emiter, originPoultererID);
            assert.equal(tx.logs[0].args.price, productPrice1);

            // Fetch the data for the added dan previously
            const resultBufferOne = await this.contract.fetchItemBufferPublic.call(upc);

            // Verify the result set. Item state will be ForSaleToDairyfactory 
            assert.equal(resultBufferOne[8], 2, 'Error: Invalid item State');
        });

        it('Call function buyItemByDairyfactory() that allows a dairy factory to buy milk from poulterer', async () => {
            // Call function buyItemByDairyfactory()
            tx = await this.contract.buyItemByDairyfactory(upc, {from: dairyfactoryID, value: productPrice1});

            assert.equal(tx.logs[0].event, 'SoldToDairyfactory');
            assert.equal(tx.logs[0].args.upc, upc);
            assert.equal(tx.logs[0].args.emiter, dairyfactoryID);

            // Fetch the data for the added dan previously
            const resultBufferOne = await this.contract.fetchItemBufferPublic.call(upc);

            // Verify the result set. Item state will be SoldToDairyfactory 
            assert.equal(resultBufferOne[8], 3, 'Error: Invalid item State');
        });

        it('Call function shipItemToDairyfactory() that allows a poulterer to ship milk to dairy factory', async () => {
            // Call function shipItemToDairyfactory()
            tx = await this.contract.shipItemToDairyfactory(upc, {from: originPoultererID});

            assert.equal(tx.logs[0].event, 'ShippedToDairyfactory');
            assert.equal(tx.logs[0].args.upc, upc);
            assert.equal(tx.logs[0].args.emiter, originPoultererID);

            // Fetch the data for the added dan previously
            const resultBufferOne = await this.contract.fetchItemBufferPublic.call(upc);

            // Verify the result set. Item state will be ShippedToDairyfactory 
            assert.equal(resultBufferOne[8], 4, 'Error: Invalid item State');
        });

        it('Call function receiveItemByDairyfactory() that allows a dairy factory to mark item as received.', async () => {
            // Call function receiveItemByDairyfactory()
            tx = await this.contract.receiveItemByDairyfactory(upc, {from: dairyfactoryID});

            assert.equal(tx.logs[0].event, 'ReceivedByDairyfactory');
            assert.equal(tx.logs[0].args.upc, upc);
            assert.equal(tx.logs[0].args.emiter, dairyfactoryID);

            // Fetch the data for the added dan previously
            const resultBufferOne = await this.contract.fetchItemBufferPublic.call(upc);

            // Verify the result set. Item state will be ReceivedByDairyfactory 
            assert.equal(resultBufferOne[8], 5, 'Error: Invalid item State');
        });

        it('Call function processMilk() that allows a dairy factory to process milk.', async () => {
            // Call function processMilk()
            tx = await this.contract.processMilk(upc, {from: dairyfactoryID});

            assert.equal(tx.logs[0].event, 'Processed');
            assert.equal(tx.logs[0].args.upc, upc);
            assert.equal(tx.logs[0].args.emiter, dairyfactoryID);

            // Fetch the data for the added dan previously
            const resultBufferOne = await this.contract.fetchItemBufferPublic.call(upc);

            // Verify the result set. Item state will be Processed 
            assert.equal(resultBufferOne[8], 9, 'Error: Invalid item State');
        });

        it('Call function packMilk() that allows a dairy factory to pack the good quality milk.', async () => {
            // Call function packMilk()
            tx = await this.contract.packMilk(upc, {from: dairyfactoryID});

            assert.equal(tx.logs[0].event, 'Packed');
            assert.equal(tx.logs[0].args.upc, upc);
            assert.equal(tx.logs[0].args.emiter, dairyfactoryID);

            // Fetch the data for the added dan previously
            const resultBufferOne = await this.contract.fetchItemBufferPublic.call(upc);

            // Verify the result set. Item state will be Packed 
            assert.equal(resultBufferOne[8], 15, 'Error: Invalid item State');
        });

        it('Call function sellToDistributor() that allows a dairy factory to sell milk to distributor', async () => {
            // Call function sellToDistributor()
            tx = await this.contract.sellToDistributor(upc, productPrice2, {from: dairyfactoryID});

            assert.equal(tx.logs[0].event, 'ForSaleToDistributor');
            assert.equal(tx.logs[0].args.upc, upc);
            assert.equal(tx.logs[0].args.emiter, dairyfactoryID);
            assert.equal(tx.logs[0].args.price, productPrice2);

            // Fetch the data for the added dan previously
            const resultBufferOne = await this.contract.fetchItemBufferPublic.call(upc);

            // Verify the result set. Item state will be ForSaleToDistributor 
            assert.equal(resultBufferOne[8], 16, 'Error: Invalid item State');
        });

        it('Call function buyItemByDistributor() that allows a distributor to buy milk from dairy factory', async () => {
            // Call function buyItemByDistributor()
            tx = await this.contract.buyItemByDistributor(upc, {from: distributorID, value: productPrice2});

            assert.equal(tx.logs[0].event, 'SoldToDistributor');
            assert.equal(tx.logs[0].args.upc, upc);
            assert.equal(tx.logs[0].args.emiter, distributorID);

            // Fetch the data for the added dan previously
            const resultBufferOne = await this.contract.fetchItemBufferPublic.call(upc);

            // Verify the result set. Item state will be SoldToDistributor 
            assert.equal(resultBufferOne[8], 17, 'Error: Invalid item State');
        });

        it('Call function shipItemToDistributor() that allows a dairy factory to ship milk to distributor', async () => {
            // Call function shipItemToDistributor()
            tx = await this.contract.shipItemToDistributor(upc, {from: dairyfactoryID});

            assert.equal(tx.logs[0].event, 'ShippedToDistributor');
            assert.equal(tx.logs[0].args.upc, upc);
            assert.equal(tx.logs[0].args.emiter, dairyfactoryID);

            // Fetch the data for the added dan previously
            const resultBufferOne = await this.contract.fetchItemBufferPublic.call(upc);

            // Verify the result set. Item state will be ShippedToDistributor 
            assert.equal(resultBufferOne[8], 18, 'Error: Invalid item State');
        });

        it('Call function receiveItemByDistributor() that allows a distributor to mark item as received.', async () => {
            // Call function receiveItemByDistributor()
            tx = await this.contract.receiveItemByDistributor(upc, {from: distributorID});

            assert.equal(tx.logs[0].event, 'ReceivedByDistributor');
            assert.equal(tx.logs[0].args.upc, upc);
            assert.equal(tx.logs[0].args.emiter, distributorID);

            // Fetch the data for the added dan previously
            const resultBufferOne = await this.contract.fetchItemBufferPublic.call(upc);

            // Verify the result set. Item state will be ReceivedByDistributor 
            assert.equal(resultBufferOne[8], 19, 'Error: Invalid item State');
        });

        it('Call function sellToRetailer() that allows a distributor to sell milk to retailer', async () => {
            // Call function sellToRetailer()
            tx = await this.contract.sellToRetailer(upc, productPrice3, {from: distributorID});

            assert.equal(tx.logs[0].event, 'ForSaleToRetailer');
            assert.equal(tx.logs[0].args.upc, upc);
            assert.equal(tx.logs[0].args.emiter, distributorID);
            assert.equal(tx.logs[0].args.price, productPrice3);

            // Fetch the data for the added dan previously
            const resultBufferOne = await this.contract.fetchItemBufferPublic.call(upc);

            // Verify the result set. Item state will be ForSaleToRetailer 
            assert.equal(resultBufferOne[8], 20, 'Error: Invalid item State');
        });

        it('Call function buyItemByRetailer() that allows a retailer to buy milk from distributor', async () => {
            // Call function buyItemByRetailer()
            tx = await this.contract.buyItemByRetailer(upc, {from: retailerID, value: productPrice3});

            assert.equal(tx.logs[0].event, 'SoldToRetailer');
            assert.equal(tx.logs[0].args.upc, upc);
            assert.equal(tx.logs[0].args.emiter, retailerID);

            // Fetch the data for the added dan previously
            const resultBufferOne = await this.contract.fetchItemBufferPublic.call(upc);

            // Verify the result set. Item state will be SoldToRetailer 
            assert.equal(resultBufferOne[8], 21, 'Error: Invalid item State');
        });

        it('Call function shipItemToRetailer() that allows a distributor to ship milk to retailer', async () => {
            // Call function shipItemToRetailer()
            tx = await this.contract.shipItemToRetailer(upc, {from: distributorID});

            assert.equal(tx.logs[0].event, 'ShippedToRetailer');
            assert.equal(tx.logs[0].args.upc, upc);
            assert.equal(tx.logs[0].args.emiter, distributorID);

            // Fetch the data for the added dan previously
            const resultBufferOne = await this.contract.fetchItemBufferPublic.call(upc);

            // Verify the result set. Item state will be ShippedToRetailer 
            assert.equal(resultBufferOne[8], 22, 'Error: Invalid item State');
        });

        it('Call function receiveItemByRetailer() that allows a distributor to mark item as received.', async () => {
            // Call function receiveItemByRetailer()
            tx = await this.contract.receiveItemByRetailer(upc, {from: retailerID});

            assert.equal(tx.logs[0].event, 'ReceivedByRetailer');
            assert.equal(tx.logs[0].args.upc, upc);
            assert.equal(tx.logs[0].args.emiter, retailerID);

            // Fetch the data for the added dan previously
            const resultBufferOne = await this.contract.fetchItemBufferPublic.call(upc);

            // Verify the result set. Item state will be ReceivedByRetailer 
            assert.equal(resultBufferOne[8], 23, 'Error: Invalid item State');
        });

        it('Call function sellToSuperMarket() that allows a retailer to sell milk to supermarket', async () => {
            // Call function sellToSuperMarket()
            tx = await this.contract.sellToSuperMarket(upc, productPrice4, {from: retailerID});

            assert.equal(tx.logs[0].event, 'ForSaleToSupermarket');
            assert.equal(tx.logs[0].args.upc, upc);
            assert.equal(tx.logs[0].args.emiter, retailerID);
            assert.equal(tx.logs[0].args.price, productPrice4);

            // Fetch the data for the added dan previously
            const resultBufferOne = await this.contract.fetchItemBufferPublic.call(upc);

            // Verify the result set. Item state will be ForSaleToSupermarket 
            assert.equal(resultBufferOne[8], 24, 'Error: Invalid item State');
        });

        it('Call function buyItemBySupermarket() that allows a supermarket to buy milk from retailer', async () => {
            // Call function buyItemBySupermarket()
            tx = await this.contract.buyItemBySupermarket(upc, {from: supermarketID, value: productPrice4});

            assert.equal(tx.logs[0].event, 'SoldToSupermarket');
            assert.equal(tx.logs[0].args.upc, upc);
            assert.equal(tx.logs[0].args.emiter, supermarketID);

            // Fetch the data for the added dan previously
            const resultBufferOne = await this.contract.fetchItemBufferPublic.call(upc);

            // Verify the result set. Item state will be SoldToSupermarket 
            assert.equal(resultBufferOne[8], 25, 'Error: Invalid item State');
        });

        it('Call function shipItemToSupermarket() that allows a retailer to ship milk to supermarket', async () => {
            // Call function shipItemToSupermarket()
            tx = await this.contract.shipItemToSupermarket(upc, {from: retailerID});

            assert.equal(tx.logs[0].event, 'ShippedToSupermarket');
            assert.equal(tx.logs[0].args.upc, upc);
            assert.equal(tx.logs[0].args.emiter, retailerID);

            // Fetch the data for the added dan previously
            const resultBufferOne = await this.contract.fetchItemBufferPublic.call(upc);

            // Verify the result set. Item state will be ShippedToSupermarket 
            assert.equal(resultBufferOne[8], 26, 'Error: Invalid item State');
        });

        it('Call function receiveItemBySupermarket() that allows a distributor to mark item as received.', async () => {
            // Call function receiveItemBySupermarket()
            tx = await this.contract.receiveItemBySupermarket(upc, {from: supermarketID});

            assert.equal(tx.logs[0].event, 'ReceivedBySupermarket');
            assert.equal(tx.logs[0].args.upc, upc);
            assert.equal(tx.logs[0].args.emiter, supermarketID);

            // Fetch the data for the added dan previously
            const resultBufferOne = await this.contract.fetchItemBufferPublic.call(upc);

            // Verify the result set. Item state will be ReceivedBySupermarket 
            assert.equal(resultBufferOne[8], 27, 'Error: Invalid item State');
        });

        it('Call function sellToConsumer() that allows a supermarket to sell milk to consumer', async () => {
            // Call function sellToConsumer()
            tx = await this.contract.sellToConsumer(upc, productPrice5, {from: supermarketID});

            assert.equal(tx.logs[0].event, 'ForSaleToConsumer');
            assert.equal(tx.logs[0].args.upc, upc);
            assert.equal(tx.logs[0].args.emiter, supermarketID);
            assert.equal(tx.logs[0].args.price, productPrice5);

            // Fetch the data for the added dan previously
            const resultBufferOne = await this.contract.fetchItemBufferPublic.call(upc);

            // Verify the result set. Item state will be ForSaleToConsumer 
            assert.equal(resultBufferOne[8], 28, 'Error: Invalid item State');
        });

        it('Call function buyItemByConsumer() that allows a consumer to buy milk from supermarket', async () => {
            // Call function buyItemByConsumer()
            tx = await this.contract.buyItemByConsumer(upc, {from: consumerID, value: productPrice5});

            assert.equal(tx.logs[0].event, 'SoldToConsumer');
            assert.equal(tx.logs[0].args.upc, upc);
            assert.equal(tx.logs[0].args.emiter, consumerID);

            // Fetch the data for the added dan previously
            const resultBufferOne = await this.contract.fetchItemBufferPublic.call(upc);

            // Verify the result set. Item state will be SoldToConsumer 
            assert.equal(resultBufferOne[8], 29, 'Error: Invalid item State');
        });

        it('Call function purchaseItemByConsumer() that allows a consumer to purchase milk from supermarket', async () => {
            // Call function purchaseItemByConsumer()
            tx = await this.contract.purchaseItemByConsumer(upc, {from: consumerID});

            assert.equal(tx.logs[0].event, 'PurchasedByConsumer');
            assert.equal(tx.logs[0].args.upc, upc);
            assert.equal(tx.logs[0].args.emiter, consumerID);

            // Fetch the data for the added dan previously
            const resultBufferOne = await this.contract.fetchItemBufferPublic.call(upc);

            // Verify the result set. Item state will be PurchasedByConsumer 
            assert.equal(resultBufferOne[8], 30, 'Error: Invalid item State');
        });

        it('Call function fetchItemBufferDistributor() that allows a distributor to fetch data from the supply chain smart contract.', async () => {
            // Fetch the data for the added previuosly
            const resultBufferForDistributor = await this.contract.fetchItemBufferDistributor.call(upc);
            // Verify the result set. Item state will be SoldToDistributor
            assert.equal(resultBufferForDistributor[0], sku, 'Error: Invalid sku');
            assert.equal(resultBufferForDistributor[1], upc, 'Error: Invalid upc');
            assert.equal(resultBufferForDistributor[2], consumerID, 'Error: Invalid ownerID');
            assert.equal(resultBufferForDistributor[3], distributorID, 'Error: Invalid originPoultererID');
            assert.equal(resultBufferForDistributor[4], originFarmName, 'Error: Invalid originFarmName');
            assert.equal(resultBufferForDistributor[5], originFarmInformation, 'Error: Invalid originFarmInformation');
            assert.equal(resultBufferForDistributor[6], originFarmLatitude, 'Error: Invalid originFarmLatitude');
            assert.equal(resultBufferForDistributor[7], originFarmLongitude, 'Error: Invalid originFarmLongitude');
            assert.equal(resultBufferForDistributor[8], productNotes, 'Error: Invalid productNotes');
            assert.equal(resultBufferForDistributor[9], 30, 'Error: Invalid item State');
        });

        it('Call function fetchItemBufferConsumer() that allows a consumer to fetch data from the supply chain smart contract.', async () => {
            // Fetch the data for the added previuosly
            const resultBufferForDistributor = await this.contract.fetchItemBufferConsumer.call(upc);
            // Verify the result set. Item state will be SoldToDistributor
            assert.equal(resultBufferForDistributor[0], sku, 'Error: Invalid sku');
            assert.equal(resultBufferForDistributor[1], upc, 'Error: Invalid upc');
            assert.equal(resultBufferForDistributor[2], consumerID, 'Error: Invalid ownerID');
            assert.equal(resultBufferForDistributor[3], consumerID, 'Error: Invalid originPoultererID');
            assert.equal(resultBufferForDistributor[4], originFarmName, 'Error: Invalid originFarmName');
            assert.equal(resultBufferForDistributor[5], productNotes, 'Error: Invalid productNotes');
            assert.equal(resultBufferForDistributor[6], distributorID, 'Error: Invalid distributorID');
            assert.equal(resultBufferForDistributor[7], 30, 'Error: Invalid item State');
        });
    });
});


const expectThrow = async (promise) => {
    try {
        await promise;
    } catch (error) {
        assert.exists(error);
        return;
    }

    assert.fail('Expected an error but didnt see one!');
};